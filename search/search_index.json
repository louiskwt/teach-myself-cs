{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Solo-leveling</p> <p>Seize your day to study and become the best verion of you!</p>"},{"location":"6.100/","title":"Notes Index","text":"<ol> <li> <p>Lecture 1</p> </li> <li> <p>Lecture 2</p> </li> </ol>"},{"location":"6.100/lecture1/","title":"Lecture 1","text":"<p>Topics Cover</p> <ol> <li>Solving problems using computation</li> <li>python programming language</li> <li>organising modular program</li> <li>Algorithms</li> <li>Algorithmic complexity</li> </ol> <p>CS focsues on the imperative knowledge (how to / recipe) not the declarative knowledge (statements of facts)</p>"},{"location":"6.100/lecture1/#imparative-knowledge-example-finding-square-root-with-newtons-method","title":"Imparative Knowledge Example (Finding Square Root with Newton's Method)","text":"<ol> <li>Start with a guess g</li> <li>if g * g is close enough to x, stop and say g is the square root</li> <li>else make a new guess by averaging g and x / g</li> <li>using the new guess, repeat the process until it's close enough</li> </ol> <p>We have an algorithm</p> <ol> <li>Sequence of simple steps</li> <li>flow of control</li> <li>a mean to determine when to stop</li> </ol>"},{"location":"6.100/lecture1/#big-idea","title":"Big Idea:","text":"<p>Although computer is powerful for processing data, it can only do what you tell it to do.</p>"},{"location":"6.100/lecture1/#basic-primitives","title":"Basic Primitives","text":"<p>Turing showed that you can compute anything with only 6 primitives: left, right, print, scan, erase, no op</p> <p>Church-Turing Thesis: if a functoin is computable, a Turing Machine can be programmed to compute it</p> <p>The if in Church-Turin thesis is important because not all function is computable.</p> <p>E.g.</p> <ul> <li>halting problem</li> </ul> <p>it is impossible to write a program that given an arbitrary program, call it P, prints true if and only if it runs forever</p> <p>Turing Completeness: A programming language is Turing complete if it can be used to simulatre a universal Turing machine. (Most modern programming langauges are)</p> <p>Real programming languages have more convenient set of primitives and ways to combine primitives to create new primitives</p> <p>Anything computable in one language is computable in any other programming language</p>"},{"location":"6.100/lecture1/#aspects-of-language","title":"Aspects of language","text":"<p>Program only has one meaning, but the meaning may not be what you intend</p> <p>How things can go wrong in programming</p> <ol> <li>syntax error</li> <li>static semantic error (valid syntax but invalid meaning or not meaningful)</li> <li>the output is not what you intended! (semantic error)</li> </ol>"},{"location":"6.100/lecture1/#what-is-programming-about","title":"what is programming about","text":"<p>It's about creating data objects and manipulating them</p> <p>Objects have a type that defines the kinds of things programs can do them</p> <ul> <li> <p>Scalar object (no internal structure)</p> </li> <li> <p>int</p> </li> <li>float</li> <li>bool</li> <li> <p>NoneType</p> </li> <li> <p>Non-scalar (has an internal structure / can be subdivided into smaller elements)</p> </li> <li> <p>list</p> </li> <li>dictionary</li> <li>str</li> </ul>"},{"location":"6.100/lecture1/#type-casting","title":"Type Casting","text":"<p>convert one object to another type</p> <p>float(3)</p> <p>But the original object is still in memory not modified</p> <p>Python follows these principles for type casting:</p> <ul> <li>Immutable types (e.g., int, float, str) cannot be modified in place.</li> <li>Operations that \"change\" a value actually return a new object.</li> </ul> <p>This prevents unintended side effects and makes Python safer for concurrent execution.</p>"},{"location":"6.100/lecture1/#expressions","title":"Expressions","text":"<p>In programming, expression is any code that evaluates to a value, it can be</p> <ol> <li>literals (e.g., \"hello\", 42)</li> <li>variables (e.g., x)</li> <li>function calls (e.g. type(x))</li> <li>operator (e.g."},{"location":"6.100/lecture1/#operators-on-int-and-float","title":"Lecture 1","text":""},{"location":"6.100/lecture1/#variables","title":"Lecture 1","text":""},{"location":"6.100/lecture1/#computational-thinkinng","title":"Lecture 1","text":""},{"location":"6.100/lecture2/","title":"Lecture 2","text":""},{"location":"6.100/lecture2/#reading-notes","title":"Reading notes","text":"<p>Method or operator overloaded: it has different meanings depending upon the type of objects to which it is applied</p> <ul> <li>when * is applied to an int and a str, it becomes a repetition operator</li> <li>n*s = repeat str s n times</li> </ul> <p>String in python is a non-secular object</p> <ul> <li>can be accessed using index</li> <li> <p>slicing s[start: end]</p> <ol> <li>by default the start is set to 0; and the end is set to len(s)</li> </ol> </li> <li> <p>input will give you back a str</p> </li> </ul> <p>python map</p> <ul> <li>map(f1, list) apply f1 to every item in the list</li> </ul>"},{"location":"6.100/lecture2/#lecture-notes","title":"Lecture notes","text":""},{"location":"6.100/lecture2/#recap","title":"Recap","text":"<p>Objects have type and the types tell what operations you can do with the objects</p>"},{"location":"6.100/lecture2/#strings","title":"strings","text":"<p>Think of it as a sequence</p> <p>negative indexing</p> <ul> <li>-1 will give you the last character of the str</li> </ul> <p>slice to get substring</p> <ul> <li>s[start:end:step] step by default is 1</li> <li>for the ending, we go up to but not including the end index</li> </ul> <p>Examples</p> <p>s = \"abcdefgh\"</p> <p>s[3:6] -&gt; \"def\" s[3:6:2] -&gt; \"df\" s[:] -&gt; \"abcedfgh\" (make a copy) s[::-1] -&gt; \"hgfdecba\" (reverse the string) s[4:1:-2] -&gt; \"ec\"</p> <p>Immutable string</p> <p>strings are immutable</p> <p>you can create new objects that are versions of the original one</p>"},{"location":"6.100/lecture2/#input","title":"input","text":"<p>comma (,) in print automatically insert a space</p>"},{"location":"6.100/lecture2/#f-string","title":"f-string","text":"<p>become available in python 3.6</p> <p>var = \"I'm\" f\"{var} here\"</p> <p>place variables and expressions inside f string and no need to think about concatination</p>"},{"location":"6.100/lecture2/#condition-and-branching","title":"condition and branching","text":"<p>two notions of equal</p> <ol> <li> <p>assignment (=) -&gt; variable = 23</p> </li> <li> <p>== -&gt; test for equality</p> <ul> <li>some expression == expression (evaluate to True or False)</li> <li>similar for other comparisons 2 &lt; 3 (gets evaluated to True)</li> </ul> </li> </ol>"}]}